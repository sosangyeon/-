큰 배열이 있을 때 효율적으로 비교 탐색이 가능한가를 묻는 문제.
dictionary, 이진 탐색의 2가지를 이용해서 풀이 가능
(속도는 dictionary가 좋음)

이진 탐색이란?
정렬된 배열이나 리스트에서 특정 값을 효율적으로 찾기 위해 사용되는 알고리즘이다.
이진 탐색은 배열을 매번 절반으로 나누어 원한는 값을 탐색하므로, 시간 복잡도가 매우 효율적인 O(log n)이다.

이진 탐색의 동작 원리:
1. 전제 조건 : 이진 탐색은 정렬된 배열에서만 동작한다. 데이터가 정렬되어 있지 않으면 사용할 수 없다.
2. 중간 값 선택 : 배열의 중간 값을 선택하고, 그 값과 찾고자 하는 값을 비교한다.
3. 비교 후 절반으로 나누기 : 
찾고자 하는 값이 중간 값보다 크면, 배열의 오른쪽 절반에서 탐색을 이어간다.
찾고자 하는 값이 중간 값보다 작으면, 배열의 왼쪽 절반에서 탐색을 이어간다.
4. 반복 또는 재귀 : 이 과정을 값이 발견될 때까지 반복하거나, 더 이상 나눌 배열이 없을 때까지 진행한다.

주의점 : 정렬된 배열에서만 사용 가능하다. 정렬되지 않은 배열에서는 이진 탐색을 수행할 수 없기 때문에, 
먼저 배열을 정렬하는 과정이 필요할 수 있다.

dictionary가 속도가 빠른 이유
hash table을 사용하기 때문이다. 
딕셔너리는 키-값 쌍을 저장하고, 특정 키에 대한 값을 빠르게 찾을 수 있도록 설계되었다.
해시 테이블은 특정한 키를 입력받아 해시 함수를 통해 해달 키의 해시 값을 계산한다. 이 해시 값은 데이터가 저장될 메모리 위치를 나타내며,
이를 통해 키를 배열의 인덱스처럼 사용할 수 있다.

sys.stdin.readline()과 input()의 차이점

항목	      input()	                   sys.stdin.readline()
속도	      느림	                     빠름
줄바꿈    	줄바꿈 자동 제거	         줄바꿈 포함 (\n)
용도	      소규모 입력 처리에 적합     대량 입력 처리에 적합
사용 방식	  고수준 입력 방식	         저수준 입력 방식


import sys
n = int(sys.stdin.readline())
cards = set(map(int, sys.stdin.readline().split()))
m = int(sys.stdin.readline())
checks = list(map(int, sys.stdin.readline().split()))

for j in range(m):
    if checks[j] not in cards:
        print(0, end = ' ')
    else:
        print(1, end=' ')
