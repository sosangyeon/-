선입선출의 자료구조, 대기열이라고도 한다. (= 큐라고도 한다.)
큐라는 단어 자체가 표 같은 것을 구매하기 위해 줄서는 것을 의미한다.
스택과 비슷하지만 조금 다르다. 
ex) 표를 사기 위해 줄을 서는 사람들
데이터가 들어오는 위치는 back,rear / 데이터가 나가는 위치는 앞 front
입력 enqueue, 출력 dequeue

구현
보통의 배열을 사용해서 큐를 구현하면 enqueue와 dequeue을 할 때마다 계속 데이터가 앞으로 밀려나는
문제가 생기는데, 이를 해결하기 위해 원형 버퍼를 사용한다.
시작 부분과 끝 부분을 포인터로 지정한 뒤 enqueue와 dequeue를 하는 형태

파이썬 예시
from typing import Any

class Queue:
    
    def __init__(self, *args: Any):
        self.__items: list[Any] = list(args)
        self.__size: int = len(self.__items)
        
    def enqueue(self, item: Any):
        self.__items.append(item)
        self.__size += 1
    
    def dequeue(self):
        if self.empty():
            raise IndexError("dequeue from empty queue")
        item: Any = self.__items.pop(0)
        self.__size -= 1
        return item

    def empty(self):
        return not self.__size
    
    def __str__(self):
        return f"{self.__items}"
    
    def __repr__(self):
        return f"{self.__items}"
    
    def __len__(self):
        return self.__size
    
    def __iter__(self):
        if self.empty():
            return None
        for item in self.__items:
            yield item

특수한 형태의 큐
1) 원형 큐
큐를 위해 배열을 지정해 놓고 큐를 쓰다보면 배열의 앞부분이 비게 된다는 점을 활용해서 배열의 맨 마지막 부분을 쓰면 다시 제일 처음부터 다시 큐를 채우기 시작하는 형태의 큐이다.
원형 큐는 일반적인 선형 큐의 한계를 극복하기 위해 고안된 데이터 구조로, 배열을 사용하여 큐를 구현할 때 배열의 끝과 시작이 연결된 형태를 취한다.
일반적인 선형 큐에서는 데이터를 추가하고 제거하는 과정에서 배열의 앞 부분이 점점 비어 가면서 사용할 수 없게 되는 공간이 생긴다.
-> 선형 큐에서는 두 가지 주요 연산이 있다. 입력 enqueue, 출력 dequeue
'앞이 비어가는' 현상
dequeue 연산 : 데이터가 큐의 front에서 제거되면, front 인덱스는 배열에서 다음 원소로 이동한다.
데이터가 제거된 배열의 초기 부분은 다시 사용되지 않게 된다.
제거된 데이터가 있던 배열의 초기 부분은 더 이상 사용되지 않고, 사실상 빈 공간이 되어 버린다. 이 공간을 재활용하지 못하는 문제가 발생한다.

원형 큐는 이 문제를 해결하기 위해 디자인되었다. 원형 큐에서는 front와 rear가 배열의 끝에 도달하면 배열의 시작으로 '원'을 그리듯이 돌아온다.
이를 통해, 큐의 모든 공간을 효율적으로 재사용할 수 있다. 
따라서 배열의 앞 부분이 비어 있을 때 그 공간을 다시 사용하여 새로운 데이터를 enqueue할 수 있다. 

enqueue를 하게 되면 rear 포인터가 앞으로 이동하고, dequeue를 하게 되면 front 포인터가 앞으로 이동한다. 
이렇게 enqueue와 dequeue를 반복하게 되면 서로 동그랗게 연결되어 있기 때문에 투 포인터가 빙글빙글 돌면서 이동하는 구조가 된다. 

큐가 가득 찼을때 rear 포인터가 바로 앞의 위치에 도달하면, 큐가 가득 찼다고 판단하고 추가적인 enqueue 연산을 수행할 수 없다.
이 때, 큐에 더 이상 공간이 없다는 에러가 발생한다.

2) 우선순위 큐
우선순위 큐는 말 그대로 원소들에게 우선순위를 매겨서 넣을 때의 순서와 상관없이 뺄 때에는 우선순위가 높은 원소부터 빼내는 것이다.
이 경우에 만약 우선순위가 낮은 원소가 들어간다면 빼낼 때에는 마음대로 나가지 못하는 상황이 발생한다.

3) 덱
일반적인 큐는 뒤에서만 삽입이 이루어지고 앞에서만 인출이 가능한데 반해 데크는 양쪽에서 모두 삽입/인출이 가능한 스택과 큐의 특징을 모두 갖고 있다.
이 추상형 자료형의 구현은 배열이나 연결 리스트 모두 가능하지만, 특별히 그림과 같이 이중 연결 리스트로 구현하는 편이 가장 잘 어울린다.
이중 연결 리스트로 구현하게 되면, 그림처럼 양쪽으로 head와 tail이라는 이름의 두 포인터를 갖고 있다가 새로운 아이템이 추가될 때마다 양쪽 또는 뒤쪽으로 연결시켜 주기만 하면 된다.

구현 방법
배열 
배열을 사용해 데크를 구현할 수 있지만, 배열의 시작이나 끝에 요소를 추가하거나 제거할 때는 비효율적일 수 있다.
특히 배열의 시작 부분에서의 작업은 모든 요소를 이동시켜야 하므로 시간이 많이 소요될 수 있다.
이중 연결 리스트
각 노드가 앞뒤 노드와의 연결 정보를 가지고 있는 연결 리스트이다.
이중 연결 리스트를 사용하면, 양쪽 끝에 있는 노드를 쉽게 추가하거나 제거할 수 있으며, 이 작업은 일반적으로 상수 시간에 수행된다.
이중 연결 리스트는 각 노드가 이전 노드와 다음 노드를 가리키는 두 개의 포인터를 사용하여 데크의 양 끝에 쉽게 접근할 수 있다.














